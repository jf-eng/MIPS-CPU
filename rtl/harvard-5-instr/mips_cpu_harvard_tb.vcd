$date
	Sat Nov 20 15:47:53 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mips_cpu_harvard_tb $end
$var wire 32 ! register_v0 [31:0] $end
$var wire 32 " instr_readdata [31:0] $end
$var wire 32 # instr_address [31:0] $end
$var wire 32 $ data_writedata [31:0] $end
$var wire 1 % data_write $end
$var wire 32 & data_readdata [31:0] $end
$var wire 1 ' data_read $end
$var wire 32 ( data_address [31:0] $end
$var wire 1 ) active $end
$var reg 1 * clk $end
$var reg 1 + clk_enable $end
$var reg 1 , reset $end
$scope module dut $end
$var wire 1 * clk $end
$var wire 1 + clk_enable $end
$var wire 32 - data_readdata [31:0] $end
$var wire 32 . instr_readdata [31:0] $end
$var wire 1 , reset $end
$var wire 5 / rt [4:0] $end
$var wire 5 0 rs [4:0] $end
$var wire 32 1 reg_read_data_0 [31:0] $end
$var wire 5 2 rd [4:0] $end
$var wire 32 3 instr_address [31:0] $end
$var wire 6 4 func_code [5:0] $end
$var wire 32 5 data_writedata [31:0] $end
$var wire 1 % data_write $end
$var wire 1 ' data_read $end
$var wire 32 6 data_address [31:0] $end
$var wire 16 7 alu_immediate [15:0] $end
$var wire 1 8 RegWrite $end
$var wire 1 9 RegDst $end
$var wire 1 : MemtoReg $end
$var wire 1 ; Branch $end
$var wire 1 < ALUSrc $end
$var wire 6 = ALUOp [5:0] $end
$var reg 1 ) active $end
$var reg 32 > register_v0 [31:0] $end
$scope module controlpathblock $end
$var wire 1 * clk $end
$var wire 32 ? instr_read_data [31:0] $end
$var wire 1 , reset $end
$var wire 5 @ rt [4:0] $end
$var wire 5 A rs [4:0] $end
$var wire 32 B reg_read_data_0 [31:0] $end
$var wire 5 C rd [4:0] $end
$var wire 32 D instruction_word [31:0] $end
$var wire 6 E instruction_opcode [5:0] $end
$var wire 32 F instr_read_addr [31:0] $end
$var wire 6 G func_code [5:0] $end
$var wire 1 % data_write $end
$var wire 1 ' data_read $end
$var wire 16 H alu_immediate [15:0] $end
$var wire 1 8 RegWrite $end
$var wire 1 9 RegDst $end
$var wire 1 : MemtoReg $end
$var wire 1 ; Branch $end
$var wire 1 < ALUSrc $end
$var wire 6 I ALUOp [5:0] $end
$scope module controlblock $end
$var wire 6 J instruction_opcode [5:0] $end
$var reg 6 K ALUOp [5:0] $end
$var reg 1 < ALUSrc $end
$var reg 1 ; Branch $end
$var reg 1 ' MemRead $end
$var reg 1 % MemWrite $end
$var reg 1 : MemtoReg $end
$var reg 1 9 RegDst $end
$var reg 1 8 RegWrite $end
$upscope $end
$scope module irblock $end
$var wire 32 L read_data [31:0] $end
$var reg 16 M alu_immediate [15:0] $end
$var reg 6 N func_code [5:0] $end
$var reg 6 O instruction_opcode [5:0] $end
$var reg 32 P instruction_word [31:0] $end
$var reg 5 Q rd [4:0] $end
$var reg 5 R rs [4:0] $end
$var reg 5 S rt [4:0] $end
$upscope $end
$scope module pcblock $end
$var wire 1 * clk $end
$var wire 1 ; immediate $end
$var wire 1 , reset $end
$var wire 32 T addr_next [31:0] $end
$var wire 32 U Rd [31:0] $end
$var reg 32 V addr [31:0] $end
$upscope $end
$upscope $end
$scope module datapathblock $end
$var wire 6 W ALUOp [5:0] $end
$var wire 1 < ALUSrc $end
$var wire 1 : MemtoReg $end
$var wire 1 9 RegDst $end
$var wire 1 8 RegWrite $end
$var wire 16 X alu_immediate [15:0] $end
$var wire 1 * clk $end
$var wire 32 Y data_address [31:0] $end
$var wire 32 Z data_readdata [31:0] $end
$var wire 32 [ data_writedata [31:0] $end
$var wire 6 \ func_code [5:0] $end
$var wire 5 ] rd [4:0] $end
$var wire 5 ^ reg_read_addr_0 [4:0] $end
$var wire 5 _ reg_read_addr_1 [4:0] $end
$var wire 1 , reset $end
$var wire 5 ` rs [4:0] $end
$var wire 5 a rt [4:0] $end
$var wire 32 b sign_extended [31:0] $end
$var wire 32 c reg_write_data [31:0] $end
$var wire 5 d reg_write_addr [4:0] $end
$var wire 32 e reg_read_data_1 [31:0] $end
$var wire 32 f reg_read_data_0 [31:0] $end
$var wire 32 g op2 [31:0] $end
$var wire 32 h alu_out [31:0] $end
$scope module alu_0 $end
$var wire 6 i ALUOp [5:0] $end
$var wire 6 j func_code [5:0] $end
$var wire 32 k op2 [31:0] $end
$var wire 32 l op1 [31:0] $end
$var reg 12 m alu_control [11:0] $end
$var reg 32 n alu_out [31:0] $end
$upscope $end
$scope module regfile_0 $end
$var wire 1 * clk $end
$var wire 5 o read_addr_0 [4:0] $end
$var wire 5 p read_addr_1 [4:0] $end
$var wire 1 , reset $end
$var wire 1 8 wen $end
$var wire 5 q write_addr [4:0] $end
$var wire 32 r write_data [31:0] $end
$var reg 32 s read_data_0 [31:0] $end
$var reg 32 t read_data_1 [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 u i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 v i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11111111 v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
1<
0;
0:
19
08
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
0,
x+
0*
x)
bx (
0'
bx &
0%
bx $
bx #
bx "
bx !
$end
#2
1*
#4
1,
0*
#6
b0xxxxxxxxxxxx c
b0xxxxxxxxxxxx r
b1000 g
b1000 k
b0xxxxxxxxxxxx (
b0xxxxxxxxxxxx 6
b0xxxxxxxxxxxx Y
b0xxxxxxxxxxxx h
b0xxxxxxxxxxxx n
b1000 m
b1000 b
b0 $
b0 5
b0 [
b0 e
b0 t
b0 1
b0 B
b0 U
b0 f
b0 l
b0 s
18
0<
1;
b0 =
b0 I
b0 K
b0 W
b0 i
b1000 4
b1000 G
b1000 N
b1000 \
b1000 j
b1000 7
b1000 H
b1000 M
b1000 X
b0 _
b0 p
b0 /
b0 @
b0 S
b0 a
b1010 ^
b1010 o
b1010 0
b1010 A
b1010 R
b1010 `
b1010000000000000000001000 D
b1010000000000000000001000 P
b0 E
b0 J
b0 O
b1010000000000000000001000 "
b1010000000000000000001000 .
b1010000000000000000001000 ?
b1010000000000000000001000 L
b10111111110000000000000000000100 T
b10111111110000000000000000000000 #
b10111111110000000000000000000000 3
b10111111110000000000000000000000 F
b10111111110000000000000000000000 V
b100000 u
1*
#8
0,
0*
#10
b0 g
b0 k
b101011000000 m
b0 b
08
1<
0;
b101011 =
b101011 I
b101011 K
b101011 W
b101011 i
b0 4
b0 G
b0 N
b0 \
b0 j
b0 7
b0 H
b0 M
b0 X
b10 _
b10 p
b10 /
b10 @
b10 S
b10 a
b100 ^
b100 o
b100 0
b100 A
b100 R
b100 `
b10101100100000100000000000000000 D
b10101100100000100000000000000000 P
b101011 E
b101011 J
b101011 O
b10101100100000100000000000000000 "
b10101100100000100000000000000000 .
b10101100100000100000000000000000 ?
b10101100100000100000000000000000 L
b10111111110000000000000000001000 T
b10111111110000000000000000000100 #
b10111111110000000000000000000100 3
b10111111110000000000000000000100 F
b10111111110000000000000000000100 V
1*
#12
0*
#14
b0 m
18
0<
1;
b0 =
b0 I
b0 K
b0 W
b0 i
b0 _
b0 p
b0 /
b0 @
b0 S
b0 a
b0 ^
b0 o
b0 0
b0 A
b0 R
b0 `
b0 D
b0 P
b0 E
b0 J
b0 O
b0 "
b0 .
b0 ?
b0 L
b10111111110000000000000000001100 T
b10111111110000000000000000001000 #
b10111111110000000000000000001000 3
b10111111110000000000000000001000 F
b10111111110000000000000000001000 V
1*
#16
0*
#18
b10111111110000000000000000010000 T
b10111111110000000000000000001100 #
b10111111110000000000000000001100 3
b10111111110000000000000000001100 F
b10111111110000000000000000001100 V
1*
#20
0*
