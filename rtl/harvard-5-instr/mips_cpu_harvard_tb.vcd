$date
	Sat Nov 20 11:43:56 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mips_cpu_harvard_tb $end
$var wire 8 ! rom_wordaddr [7:0] $end
$var wire 32 " register_v0 [31:0] $end
$var wire 8 # ram_wordaddr [7:0] $end
$var wire 32 $ instr_readdata [31:0] $end
$var wire 32 % instr_address [31:0] $end
$var wire 32 & data_writedata [31:0] $end
$var wire 1 ' data_write $end
$var wire 32 ( data_readdata [31:0] $end
$var wire 1 ) data_read $end
$var wire 32 * data_address [31:0] $end
$var wire 1 + active $end
$var reg 1 , clk $end
$var reg 1 - clk_enable $end
$var reg 1 . reset $end
$scope module dut $end
$var wire 1 , clk $end
$var wire 1 - clk_enable $end
$var wire 32 / data_readdata [31:0] $end
$var wire 32 0 instr_readdata [31:0] $end
$var wire 1 . reset $end
$var wire 5 1 shamt [4:0] $end
$var wire 5 2 rt [4:0] $end
$var wire 5 3 rs [4:0] $end
$var wire 32 4 reg_read_data_0 [31:0] $end
$var wire 5 5 rd [4:0] $end
$var wire 32 6 instr_address [31:0] $end
$var wire 6 7 func_code [5:0] $end
$var wire 32 8 data_writedata [31:0] $end
$var wire 1 ' data_write $end
$var wire 1 ) data_read $end
$var wire 32 9 data_address [31:0] $end
$var wire 16 : alu_immediate [15:0] $end
$var wire 1 ; RegWrite $end
$var wire 1 < RegDst $end
$var wire 1 = MemtoReg $end
$var wire 1 > Branch $end
$var wire 1 ? ALUSrc $end
$var wire 6 @ ALUOp [5:0] $end
$var reg 1 + active $end
$var reg 32 A register_v0 [31:0] $end
$scope module controlpathblock $end
$var wire 1 , clk $end
$var wire 32 B instr_read_data [31:0] $end
$var wire 1 . reset $end
$var wire 5 C shamt [4:0] $end
$var wire 5 D rt [4:0] $end
$var wire 5 E rs [4:0] $end
$var wire 32 F reg_read_data_0 [31:0] $end
$var wire 5 G rd [4:0] $end
$var wire 32 H instruction_word [31:0] $end
$var wire 6 I instruction_opcode [5:0] $end
$var wire 32 J instr_read_addr [31:0] $end
$var wire 6 K func_code [5:0] $end
$var wire 1 ' data_write $end
$var wire 1 ) data_read $end
$var wire 16 L alu_immediate [15:0] $end
$var wire 1 ; RegWrite $end
$var wire 1 < RegDst $end
$var wire 1 = MemtoReg $end
$var wire 1 > Branch $end
$var wire 1 ? ALUSrc $end
$var wire 6 M ALUOp [5:0] $end
$scope module controlblock $end
$var wire 6 N instruction_opcode [5:0] $end
$var wire 6 O func_code [5:0] $end
$var reg 6 P ALUOp [5:0] $end
$var reg 1 ? ALUSrc $end
$var reg 1 > Branch $end
$var reg 1 ) MemRead $end
$var reg 1 ' MemWrite $end
$var reg 1 = MemtoReg $end
$var reg 1 < RegDst $end
$var reg 1 ; RegWrite $end
$upscope $end
$scope module irblock $end
$var wire 32 Q read_data [31:0] $end
$var reg 16 R alu_immediate [15:0] $end
$var reg 6 S func_code [5:0] $end
$var reg 6 T instruction_opcode [5:0] $end
$var reg 32 U instruction_word [31:0] $end
$var reg 5 V rd [4:0] $end
$var reg 5 W rs [4:0] $end
$var reg 5 X rt [4:0] $end
$var reg 5 Y shamt [4:0] $end
$upscope $end
$scope module pcblock $end
$var wire 1 , clk $end
$var wire 1 > immediate $end
$var wire 1 . reset $end
$var wire 32 Z addr_next [31:0] $end
$var wire 32 [ Rd [31:0] $end
$var reg 32 \ addr [31:0] $end
$upscope $end
$upscope $end
$scope module datapathblock $end
$var wire 6 ] ALUOp [5:0] $end
$var wire 1 ? ALUSrc $end
$var wire 1 = MemtoReg $end
$var wire 1 < RegDst $end
$var wire 1 ; RegWrite $end
$var wire 16 ^ alu_immediate [15:0] $end
$var wire 1 , clk $end
$var wire 32 _ data_address [31:0] $end
$var wire 32 ` data_readdata [31:0] $end
$var wire 32 a data_writedata [31:0] $end
$var wire 6 b func_code [5:0] $end
$var wire 5 c rd [4:0] $end
$var wire 5 d reg_read_addr_0 [4:0] $end
$var wire 5 e reg_read_addr_1 [4:0] $end
$var wire 1 . reset $end
$var wire 5 f rs [4:0] $end
$var wire 5 g rt [4:0] $end
$var wire 32 h sign_extended [31:0] $end
$var wire 32 i reg_write_data [31:0] $end
$var wire 5 j reg_write_addr [4:0] $end
$var wire 32 k reg_read_data_1 [31:0] $end
$var wire 32 l reg_read_data_0 [31:0] $end
$var wire 32 m op2 [31:0] $end
$var wire 32 n alu_out [31:0] $end
$scope module alu_0 $end
$var wire 6 o ALUOp [5:0] $end
$var wire 6 p func_code [5:0] $end
$var wire 32 q op2 [31:0] $end
$var wire 32 r op1 [31:0] $end
$var reg 32 s alu_out [31:0] $end
$upscope $end
$scope module regfile_0 $end
$var wire 1 , clk $end
$var wire 5 t read_addr_0 [4:0] $end
$var wire 5 u read_addr_1 [4:0] $end
$var wire 1 . reset $end
$var wire 1 ; wen $end
$var wire 5 v write_addr [4:0] $end
$var wire 32 w write_data [31:0] $end
$var reg 32 x read_data_0 [31:0] $end
$var reg 32 y read_data_1 [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 z i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 { i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11111111 {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
1?
0>
0=
1<
0;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
0.
x-
0,
x+
bx *
0)
bx (
0'
bx &
bx %
bx $
b0xxxxxx #
bx "
b0xxxxxx !
$end
#2
1,
#4
1.
0,
#6
b1 i
b1 w
b1 (
b1 /
b1 `
b1 #
b100 *
b100 9
b100 _
b100 n
b100 s
b100 m
b100 q
b100 h
b1 j
b1 v
b0 &
b0 8
b0 a
b0 k
b0 y
b0 4
b0 F
b0 [
b0 l
b0 r
b0 x
1;
1=
1)
b100011 @
b100011 M
b100011 P
b100011 ]
b100011 o
b100 7
b100 K
b100 O
b100 S
b100 b
b100 p
b100 :
b100 L
b100 R
b100 ^
b0 1
b0 C
b0 Y
b0 5
b0 G
b0 V
b0 c
b1 e
b1 u
b1 2
b1 D
b1 X
b1 g
b0 d
b0 t
b0 3
b0 E
b0 W
b0 f
b10001100000000010000000000000100 H
b10001100000000010000000000000100 U
b100011 I
b100011 N
b100011 T
b10001100000000010000000000000100 $
b10001100000000010000000000000100 0
b10001100000000010000000000000100 B
b10001100000000010000000000000100 Q
b0 !
b10111111110000000000000000000100 Z
b10111111110000000000000000000000 %
b10111111110000000000000000000000 6
b10111111110000000000000000000000 J
b10111111110000000000000000000000 \
b100000 z
1,
#8
0.
0,
#10
b10 i
b10 w
b10 (
b10 /
b10 `
b10 #
b1000 *
b1000 9
b1000 _
b1000 n
b1000 s
b1000 m
b1000 q
b1000 h
b10 j
b10 v
b1000 7
b1000 K
b1000 O
b1000 S
b1000 b
b1000 p
b1000 :
b1000 L
b1000 R
b1000 ^
b10 e
b10 u
b10 2
b10 D
b10 X
b10 g
b10001100000000100000000000001000 H
b10001100000000100000000000001000 U
b10001100000000100000000000001000 $
b10001100000000100000000000001000 0
b10001100000000100000000000001000 B
b10001100000000100000000000001000 Q
b1 !
b10111111110000000000000000001000 Z
b10111111110000000000000000000100 %
b10111111110000000000000000000100 6
b10111111110000000000000000000100 J
b10111111110000000000000000000100 \
b0 &
b0 8
b0 a
b0 k
b0 y
1,
#12
0,
#14
b1 #
bx (
bx /
bx `
b11 m
b11 q
b100 i
b100 w
b100 *
b100 9
b100 _
b100 n
b100 s
b11 h
b11 j
b11 v
b1 4
b1 F
b1 [
b1 l
b1 r
b1 x
0;
0=
0)
b1001 @
b1001 M
b1001 P
b1001 ]
b1001 o
b11 7
b11 K
b11 O
b11 S
b11 b
b11 p
b11 :
b11 L
b11 R
b11 ^
b11 e
b11 u
b11 2
b11 D
b11 X
b11 g
b1 d
b1 t
b1 3
b1 E
b1 W
b1 f
b100100001000110000000000000011 H
b100100001000110000000000000011 U
b1001 I
b1001 N
b1001 T
b100100001000110000000000000011 $
b100100001000110000000000000011 0
b100100001000110000000000000011 B
b100100001000110000000000000011 Q
b10 !
b10111111110000000000000000001100 Z
b10111111110000000000000000001000 %
b10111111110000000000000000001000 6
b10111111110000000000000000001000 J
b10111111110000000000000000001000 \
b0 &
b0 8
b0 a
b0 k
b0 y
1,
#16
0,
#18
b0 #
b10 i
b10 w
b0 m
b0 q
b10 *
b10 9
b10 _
b10 n
b10 s
b1100000100001 h
b10 4
b10 F
b10 [
b10 l
b10 r
b10 x
1;
0?
b0 @
b0 M
b0 P
b0 ]
b0 o
b100001 7
b100001 K
b100001 O
b100001 S
b100001 b
b100001 p
b1100000100001 :
b1100000100001 L
b1100000100001 R
b1100000100001 ^
b11 5
b11 G
b11 V
b11 c
b10 d
b10 t
b10 3
b10 E
b10 W
b10 f
b10000110001100000100001 H
b10000110001100000100001 U
b0 I
b0 N
b0 T
b10000110001100000100001 $
b10000110001100000100001 0
b10000110001100000100001 B
b10000110001100000100001 Q
b11 !
b10111111110000000000000000010000 Z
b10111111110000000000000000001100 %
b10111111110000000000000000001100 6
b10111111110000000000000000001100 J
b10111111110000000000000000001100 \
1,
#20
0,
#22
b100 !
b10111111110000000000000000010100 Z
b10111111110000000000000000010000 %
b10111111110000000000000000010000 6
b10111111110000000000000000010000 J
b10111111110000000000000000010000 \
b1 #
b100 i
b100 w
b100 *
b100 9
b100 _
b100 n
b100 s
b10 m
b10 q
b10 &
b10 8
b10 a
b10 k
b10 y
1,
#24
0,
#26
b101 !
b10111111110000000000000000011000 Z
b10111111110000000000000000010100 %
b10111111110000000000000000010100 6
b10111111110000000000000000010100 J
b10111111110000000000000000010100 \
b110 i
b110 w
b110 *
b110 9
b110 _
b110 n
b110 s
b100 m
b100 q
b100 &
b100 8
b100 a
b100 k
b100 y
1,
#28
0,
#30
b110 !
b10111111110000000000000000011100 Z
b10111111110000000000000000011000 %
b10111111110000000000000000011000 6
b10111111110000000000000000011000 J
b10111111110000000000000000011000 \
b10 #
b1000 i
b1000 w
b1000 *
b1000 9
b1000 _
b1000 n
b1000 s
b110 m
b110 q
b110 &
b110 8
b110 a
b110 k
b110 y
1,
#32
0,
